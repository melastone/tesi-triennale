// TEST GASTAP VS SOLC COMPILER

  % assegnazione
/ assignment.sol {
  inizializza una var, poi gli assegna un valore.

  GASTAP: 9+20138

  ~init()
  GASTAP: 9+20138
  solc: 20147
}



  % assegnazione
/ assigment2.sol {
  inizializza una var.

  GASTAP: 9+137
  solc: 81 + 28200 = 28281 (construction)

  ~init()
  GASTAP: 9+137
  solc:	146

}



% assegnazione
/ assigment3.sol {
  inizializza una var.

  GASTAP: 9+124
  solc: 5087 + 26800 = 31887 (construction)

  ~init()
  GASTAP: 9+124
  solc:	133

}


  % ciclo for
/ loop1.sol {

  Calcola la moltiplicazione di 5*7.

  GASTAP: 9+ (222+20476*nat(a))

  solc: 5099 + 39200 = 44299 (construction)

    ~ multiply(uint256)
    GASTAP: 9+ (222+20476*nat(a))
    solc: infinite

  N.B.: in questo caso la fun prende un argomento. Anche se il codice sol non
  contiene cicli, in fase di compilazione il passaggio di arg viene tradotto in
  un ciclo nel bytecode EVM. Penso sia per questo motivo che l'output sia
  parametrico....

}


  % ciclo for
/ loop2.sol {

  Somma i primi 5 elementi di un vettore.

  GASTAP: 3*max([4+nat(nums)+1,4+nat(nums)+2])+pow(max([4+nat(nums)+1,4+nat(nums)+2]),2)/512+ (1746+3* (1/32))
  solc: 111 + 59200 = 59311 (construction)

    ~ suma(uint256[])
    GASTAP: 3*max([4+nat(nums)+1,4+nat(nums)+2])+pow(max([4+nat(nums)+1,4+nat(nums)+2]),2)/512+ (1746+3* (1/32))
    solc:	infinite

}



 % for annidati
/ nested*.sol {


  / nested1.sol {

    ~suma(uint256)
    GASTAP: 15+ (20508+70*nat(a))
    solc: infinite

  }

  Che cosa accade incrementando il livello di annidamento?
    solc: infinito (per ogni liv > 0)
    GASTAP:
      - liv == 1 -> 15+ (20508+70*nat(a))
      - liv == 2 -> 15+ (20548+70*nat(a)+20276*nat(a))
      - liv == 3 -> 15+ (20588+70*nat(a)+20276*nat(a)+20276*nat(a))
      - liv == 4 -> 15+ (20628+70*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a))
      ....
      - liv == 10 -> 15+ (20908+70*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a))
      ...
      - liv == 14 -> 15+ (21028+70*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a)+20276*nat(a))
      - liv == 15 -> null
        GASTAP non riesce a mappare le funzioni nella outline, impedendo di valutare il bound.
        Il limite è dovuto alla struttura del programma.
}



% ciclo while
/ while1.sol {

GASTAP: 9+ (209+20271*nat(a))
solc: 5093 + 37600 = 42693 (construction)

~init(uint256)
GASTAP: 9+ (209+20271*nat(a))
solc:	infinite

}



% ciclo while
/ while2.sol  {
  calcola la radice quadrata.
  While. Sconsigliano l'uso in quanto consuma elevate qtà di gas!

  GASTAP: Exception: error(existence_error(procedure,evm_solver:non_terminating/2),context(evm_solver:print_ub/4,_G28))
  solc: infinite

}




  % ricorsione diretta
/ ricorsione-diretta.sol {

  GASTAP: ../../bin/ethirweb   /tmp/ei_filessNlmMy/noname1.sol  -entries  -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
  solc: 93 + 42200 = 42293 (construction)

  ~ fact(uint256)
  GASTAP: ../../bin/ethirweb   /tmp/ei_filesKu7YaR/noname1.sol  -entries  Factorial.fact:uint256 -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
  solc: infinite

}



  % ricorsione indiretta
/ ricorsione_indiretta.sol {

  Funzioni che si richiamano l'un l'atra.

  GASTAP: ../../bin/ethirweb   /tmp/ei_files8oo77i/noname1.sol  -entries  -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
  solc: 117 + 68600 = 68717 (construction)

    ~due(uint256)
    GASTAP: ../../bin/ethirweb   /tmp/ei_filesSyqnDG/noname1.sol  -entries  ricorsione_indiretta.due:uint256 -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
    solc:	infinite
    ~uno(uint256)
    GASTAP: /tmp/ei_files7DDUGq/noname1.sol  -entries  ricorsione_indiretta.uno:uint256 -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
    solc: infinite

}



  % ricorsione multipla
/ ricorsione-multipla.sol {

  GASTAP: ../../bin/ethirweb   /tmp/ei_filesBg9Aac/noname1.sol  -entries  -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
  solc: 99 + 45600 = 45699 (construction)

    ~fact(uint256)
    GASTAP: ../../bin/ethirweb   /tmp/ei_filesyYrbfT/noname1.sol  -entries  Fibonacci.fact:uint256 -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
    solc:	infinite

}



  %funzioni che si richiamano a vicenda
/ four_functions.sol {

  GASTAP: ../../bin/ethirweb   /tmp/ei_filesuaKper/noname1.sol  -entries  Sum.suma Sum.hola Sum.adios:uint256 Sum.comer:uint256 -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
  solc: 135 + 83800 = 83935 (construction)

     ~adios(uint256), comer(uint256), hola()
     bound costante che coincide.
     ~suma()
     GASTAP: 15+802
     solc: infinite

}



  % caso di studio
/ CryptoPhoenix.sol {

    selezionando il main method GASTAP restituisce:
        ../../bin/ethirweb   /tmp/ei_filesgfCwog/CryptoPhoenix.sol  -entries  -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml

    mentre solc come construction restituisce:
        infinite + 2592000 = infinite

    Selezionando invece i singoli metododi riusciamo ad ottenere una stima piuttosto precisa.

    ~ BASE_PRICE()
    GASTAP: 15+663 = 678
    solc: 678

    Quindi la stima di GASTAP coincide perfettamente con i consumi calcolati da solc.

    Le stesse considerazioni sono valide per i seguenti metodi:
    ~ owner()
    ~ paused()
    ~ subDevOne()
    ~ SCORES(uint256)
    ~ PHOENIXES(uint256)
    ~ POOLS(uint256)
    ~ devFunds(address)
    ~ GAME_STARTED()
    ~ userFunds(address)
    ~ DENOMINATOR()
    ~ GAME_END()
    ~ subDevTwo()
    ~ owner() - Ownable
    ~ paused() - Pausable
    ~ owner() - Pausable


    Casi dove il bound è pressoché simile:

    ~ unpause() - CryptoPhoenixesCivilWar
    ~ pause() - CryptoPhoenixesCivilWar
    ~ pause() - Pausable
    ~ unpause()

    Casi in cui solc produce un bound infinito:
    GASTAP non riesce a determinare un output utile:

    ~ useAbility(uint256)
    GASTAP: ../../bin/ethirweb   /tmp/ei_filesWfPcDn/CryptoPhoenix.sol  -entries  CryptoPhoenixesCivilWar.useAbility:uint256 -type_file  solidity  > /dev/null ; cat /tmp/costabs/output.xml
    solc: infinite

    Le stesse considerazioni valgono per i metodi:
    ~ endGame()
    ~ setPhoenixOwners(address[19])
    ~ useCaptainAbility(uint256)
    ~ purchasePhoenix(uint256)

      Oppure si comporta diversamente:

    ~ devWihdraw()
    GASTAP: 12+40762
    solc: infinite

    ~ upgradeContract(address)
    GASTAP: 12+36449
    solc: infinite

    ~ startGame():
    GASTAP: 12+458422
    solc: infinite

    ~ withdrawFunds()
    GASTAP: 15+41455
    solc: infinite

}
