L'analisi statica è un processo di valutazione della correttezza dei programmi che rientra tra le tecniche di verifica del software. L'aggettivo \textit{statica} identifica una serie di controlli che possono essere effettuati sul codice prima della sua esecuzione. In questo si differenzia dall'analisi dinamica, una tecnica complementare che comprende quei controlli che vengono invece effettuati a runtime.\newline
\indent L'analisi statica solitamente è il primo controllo che viene effettuato sul codice durante lo sviluppo del programma.
% Perchè l'analisi statica non è common practice?
I vantaggi apportati da questo tipo di controllo del codice sono numerosi. I bug possono essere individuati per tempo, evitando comportamenti inaspettati da parte dei programmi. Inoltre, a seconda del tool utilizzato, è possibile migliorare il codice dal punto di vista della leggibilità, della strutturazione o della performance.\newline
\indent Tuttavia l'analisi statica resta una pratica poco diffusa tra gli sviluppatori \cite{johnson2013don}. Le principali cause sono da ricondursi agli output prodotti dai tool di analisi: l'elevato numero di warning così come la presenza di falsi positivi rendono gli strumenti meno affidabili. Oltre a questo, gran parte degli informatici afferma di non utilizzare questi tool di verifica a causa del sovraccarico di lavoro: spesso i ritmi aziendali così come la scarsa collaborazione dei team di sviluppo fanno sì che non ci siano i presupposti per dedicare spazio sufficiente all'analisi del codice.\newline


\section{Analisi Statica vs. Analisi Dinamica}

Per analisi statica si intende l'analisi dei programmi dal punto di vista del codice che li compone, vale a dire senza doverli eseguire. L'analisi può essere fatta sia sul codice sorgente, che sul codice oggetto, ossia  il prodotto della compilazione.\newline
\indent L'analisi statica viene condotta su tre dimensioni: esaminando la struttura del programma, costruendo un modello che rappresenti i possibili stati del codice e ragionando sul possibile comportamento in fase di esecuzione ~\cite{ernst-ijcai97}. 
Rientrano in questa categoria la verifica formale dei programmi e le ottimizzazioni a tempo di compilazione. L'analisi statica viene spesso implementata da tool automatici, e garantisce proprietà di correttezza. Le principali critiche mosse nei confronti di questa tecnica derivano dal fatto che possa portare a dei \textit{falsi positivi}, cioè situazioni in cui viene segnalata una vulnerabilità nel codice sebbene non sia stata violata alcuna regola.
% Perchè vale questo? 
% - le proprietà sono indecidibili
% - vogliamo la soundness
La ragione di questo comportamento è legata alle proprietà che ci poniamo di verificare: la terminazione di un programma, ad esempio, è di per sè una proprietà indecidibile. \'E dimostrato matematicamente che non esiste alcun metodo di analisi statica che sia al tempo stesso \emph{corretto} e \emph{completo} e che non sia limitato dalle risorse che utilizza (es. memoria, tempo)\footnote{Questo risultato è dato dal Teorema di Rice} ~\cite{ausiello2003linguaggi}. Dunque, per ottenere degli strumenti realmente utili, siamo costretti a rinunciare alla completezza dell'analisi, preferendo dei risultati che siano corretti. Ci accontentiamo di strumenti che producono risultati approssimati, talvolta anche diversi da quelli attesi.\newline
\indent L'analisi dinamica identifica quei controlli che possono essere effettuati sul programma soltanto durante la sua esecuzione, che sia su un processore reale o virtuale. Il software testing rientra in questa categoria. Per condurre questo tipo di controllo è necessario fornire un input ben preciso e analizzare poi il comportamento del programma. Occorre inoltre stabilire a priori \emph{che cosa} si vuole misurare. Sebbene questa analisi sia più veloce rispetto alla prima, non garantisce la stessa correttezza. Per essere rigorosa infatti l'analisi dinamica dovrebbe coprire ogni possibile configurazione del programma.\\


\section{Tecniche di Analisi Statica in Informatica}

Le tecniche di analisi possono essere suddivise in due tipologie in base ai risultati prodotti. La prima categoria comprende i tool di analisi volti a localizzare bug nel codice. La seconda identifica invece un gruppo di software con una forte base logica, che utilizzano tecniche matematiche per la verifica di specifiche prorietà del programma.\newline
\indent Di seguito daremo una panoramica sulle principali tecniche ~\cite{analisi-statica-unina} di analisi statica.
% Espandiamo la sezione
% Differenziamo le tecniche manuali da quelle automatizzabili

    \subsection{La Compilazione}
    
    % Spieghiamo in dettaglio che per essere eseguita la compilazione richiede un po' di analisi

    Tutti i compilatori per eseguire la traduzione del codice dorgente in codice oggetto applicano l'analisi statica. L'operazione di compilazione, intesa come \emph{traduzione automatica}, può essere suddivisa in due macro-fasi: dal codice sorgente alla generazione della forma intermedia, e dalla forma intermedia al codice oggetto, cioè il prodotto finale. La prima fase è quella che fa più utilizzo di analisi statica; il compilatore esegue in sequenza delle trasformazioni sul codice, chiamate analisi lessicale, sintattica e semantica. \`E durante quest'ultimo passaggio che il programma viene sottoposto ai controlli relativi ai vincoli del linguaggio ~\cite{gabbrielli2011linguaggi}: si controllano le dichiarazioni delle variabili, la coerenza dei tipi, il numero dei parametri delle funzioni ecc. 
    In generale questi controlli variano a seconda del linguaggio di programmazione.\newline
    \indent La compilazione dunque non costituisce una vera e propria tecnica, ma piuttosto un tipo di controllo sul codice che non può essere risparmiato.\newline
    
    \subsection{Tecniche Manuali}
    
    Consideriamo \textit{manuali} quelle tecniche che non possono essere automatizzate da un software, ma richiedono l'interazione umana per poter essere realizzate. Di seguito ne citiamo alcune.\newline
    
        \subsubsection{Code Reading}

        Come suggerisce il termine stesso si tratta della rilettura del codice da parte di una persona. Sebbene i bug identificabili possono variare in base a diversi fattori (es. numero di persone, conoscenza del codice, livello di esperienza) questa operazione può portare alla luce difetti che invece il compilatore non rileva. Commenti inconsistenti con il codice, nomi di variabili errati, loop infiniti, codice non strutturato, sono solo alcuni di questi. L'efficacia di questa tecnica è limitata se colui che legge il codice è la stessa persona ad averlo sviluppato.\newline

        \subsubsection{Code Reviews}

        Generalmente adottata in contesti aziendali. Identifica un controllo del codice fatto in gruppo, il quale viene costituito secondo requisiti specifici. \`E una riunione dove lo sviluppatore è chiamato a leggere il codice ad alta voce di fronte ad altri esperti, che possono commentare il programma con lo scopo di individuare gli errori; in questo modo possono essere rilevati dal 30 al 70\% di quelli presenti nel programma.\newline

        \subsubsection{Walktrough}

        Molto simile alla tecnica precedente per le modalità in cui viene effettuata, poiché prevede la riunione di un gruppo di persone. Differisce negli obiettivi: cerca di trovare dei difetti nel comportamento del programma, e per farlo simula l'esecuzione del codice a mano.\newline
        
    \subsection{Tecniche Automatizzabili}
    
    Queste tecniche di revisione del codice possono essere automatizzate, al fine di implementare dei tool di analisi. Ne riportiamo alcuni esempi.\newline

        \subsubsection{Control Flow Analysis}

        Prevede la rappresentazione del codice attraverso un grafo chiamato CFG (\textit{Control Flow Graph}), dove ciascun nodo rappresenta un'istruzione o un predicato, mentre gli archi il passaggio del flusso di controllo.
        Successivamente il grafo viene analizzato, al fine di rilevare anomalie nel programma quali non strutturazione o iraggiungibilità del codice.\newline
        
        \subsubsection{Data Flow Analysis}
        
        La tecnica di analisi del data flow solitamente rientra nella categoria dei controlli dinamici. 
        Analizza l'evoluzione delle variabili durante il tempo di esecuzione, al fine di rilevare anomalie.
        Parte di questi controlli possono essere effettuati anche staticamente, permettendo di rilevare parte dei comportamenti anomali del programma, come l'uso delle variabili prima della loro dichiarazione, o l'annullamento prima dell'utilizzo.\newline
        
        \subsubsection{Esecuzione Simbolica}
        
        Consiste nell'esecuzione del programma con dei valori di input simbolici (es. espressioni) piuttosto che con i valori effettivi. Può risultare molto difficile da realizzare in caso di istruzioni if, poichè rende complesso valutare la condizione. Un altro caso che viene mal gestito è quello dei cicli, sia determinati (nel caso dipendano dal valore di una variabile) che non.\newline

\section{Analisi Statica di Smart Contract}

L'impiego delle tecniche di analisi statica per la verifica degli smart contract non è molto diffuso. Principalmente perchè data la dimensione limitata di questi programmi non si ritiene necessario il suo impiego.\newline
\indent In parte l'impopolarità dell'analisi statica è dovuta anche alla difficile rappresentazione del bytecode EVM. Decompilare le istruzioni di basso livello al fine di ottenere una rappresentazione migliore che funga da base per una buona analisi richiede un notevole sforzo. Un altro fattore a rendere poco appetibile l'applicazione di queste tecniche al mondo degli smart contract è il rischio di ottenere falsi positivi.\newline

\section{Tool per l'Analisi}
Durante questo lavoro è stato preso in considerazione un certo numero di software che implementano tecniche di analisi statica orientata alla verifica degli smart contract. Di seguito ne vedremo alcuni.

\subsection{Verificare le Proprietà di Sicurezza}

I seguenti software sono stati pensati per verificare la sicurezza dei programmi di Ethereum.\newline
\indent Il primo è uno strumento completo, per cui si può etichettare uno smart contract come \emph{sicuro} o meno. Il secondo invece è in grado di indivuare dei comportamenti anomali dei programmi causati soltanto dall'esaurimento del gas. Dunque la sua verifica comprende una tipologia circoscritta di proprietà di sicurezza.\newline

\begin{description}[labelindent=1cm]    %crea un elenco descrittivo

    \item[EtherTrust] ~\cite{grishchenko2018foundations} questo framework offre la possibilità di analizzare i programmi al fine di verificarne le proprietà di sicurezza. Tali proprietà, come ad es. la \textit{single-entrancy}, per poter essere verificate devono prima essere modellate.\newline
    \indent Per condurre la sua analisi EtherTrust produce una rappresentazione astratta del bytecode EVM nella forma di clausole di Horn. Successivamente questa rappresentazione viene data in input ad un SMT solver, il quale verifica che siano rispettate delle proprietà di sicurezza ben precise. EtherTrust garantisce la proprietà di correttezza.\newline

    \item[MadMax] ~\cite{grech2018madmax} attraverso la combinazione di più tecniche di analisi statica (analisi Data Flow e Control Flow) questo software è in grado di verificare smart contract al fine di scoprire bug legati all'esaurimento del gas disponibile.\newline
    \indent MadMax individua una serie di vulnerabilità \textit{gas-focused} in modo da definire dei pattern da ricercare attraverso l'analisi dei programmi. Questa viene condotta a partire da una rappresentazione intermedia (IR) del codice, ottenuta tramite la decompilazione del bytecode EVM.\newline

\end{description}

\subsection{Rappresentare il Bytecode EVM}

I prossimi tool utilizzano tecniche di analisi statica per fornire una miglior rappresentazione del bytecode. I risultati che si ottengono dalla loro esecuzione possono essere utilizzati per un'analisi statica volta alla verifica delle proprietà del codice.\newline

\begin{description}

    \item[KEVM] ~\cite{hildenbrandt2017kevm} produce una semantica formale per la EVM. Gli autori del programma sottolineano che la loro rappresentazione del byteocode si presta facilmente all'applicazione di tecniche di analisi, e forniscono come esempio un tool per stimare i consumi di gas degli smart contract.\newline

    \item[EthIR] ~\cite{albert2018ethir} è un framework di analisi del bytecode di EVM. A partire dalle istruzioni di basso livello, che vengono rappresentate tramite grafi CFG dal tool Oyente ~\cite{melonproject/oyente}, EthIR produce una rappresentazione \textit{Ruled Based} (RB). Tale modellizzazione può essere utilizzata per desumere proprietà del bytecode, applicando delle ulteriori tecniche di analisi statica.\newline
    
\end{description}

\subsection{Stimare i consumi di GAS}

L'ultima categoria di software che vedremo è la più interessante dal punto di vista della ricerca che abbiamo condotto. Si tratta di programmi che tramite la combinazione di tecniche di analisi statica rilevano e forniscono un bound ai consumi di gas dei programmi esaminati.\newline
\indent Li citeremo per completezza, per poi trattarli in modo più dettagliato nei capitoli successivi.\newline

\begin{description}

    \item[solc] ~\cite{solidity-docs} è il compilatore ufficiale di Solidity. Tra le opzioni di utilizzo c'è la modalità \textit{gas}, dove l'output prodotto è una stima della quantità di gas richiesto dal programma. Nella maggior parte dei casi il risultato prodotto è infinito.\newline

    \item[GASTAP] ~\cite{DBLP:journals/corr/abs-1811-10403} è la prima piattaforma sviluppata in grado di analizzare smart contract al fine di dare un upper bound ai consumi di gas dello stesso. Questo software è ancora in via di sviluppo, perciò presenta ancora delle limitazioni. Tuttavia si distingue per la precisione nella stima dei bound, riuscendo a fornire un analisi più precisa rispetto ad altri programmi che implementano le stesse funzionalità. 

\end{description}
